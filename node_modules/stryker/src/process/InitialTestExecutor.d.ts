import { RunResult } from 'stryker-api/test_runner';
import { TestFramework } from 'stryker-api/test_framework';
import { Config } from 'stryker-api/config';
import Timer from '../utils/Timer';
import { CoverageMapsByFile } from '../transpiler/CoverageInstrumenterTranspiler';
import InputFileCollection from '../input/InputFileCollection';
import SourceMapper from '../transpiler/SourceMapper';
import LoggingClientContext from '../logging/LoggingClientContext';
export interface InitialTestRunResult {
    runResult: RunResult;
    overheadTimeMS: number;
    sourceMapper: SourceMapper;
    coverageMaps: CoverageMapsByFile;
}
export default class InitialTestExecutor {
    private options;
    private inputFiles;
    private testFramework;
    private timer;
    private loggingContext;
    private readonly log;
    constructor(options: Config, inputFiles: InputFileCollection, testFramework: TestFramework | null, timer: Timer, loggingContext: LoggingClientContext);
    run(): Promise<InitialTestRunResult>;
    private runInSandbox;
    private transpileInputFiles;
    private annotateForCodeCoverage;
    private validateResult;
    /**
     * Calculates the timing variables for the test run.
     * grossTime = NetTime + overheadTime
     *
     * The overhead time is used to calculate exact timeout values during mutation testing.
     * See timeoutMS setting in README for more information on this calculation
     */
    private calculateTiming;
    /**
     * Creates a facade for the transpile pipeline.
     * Also includes the coverage instrumenter transpiler,
     * which is used to instrument for code coverage when needed.
     */
    private createTranspilerFacade;
    private getCollectCoverageHooksIfNeeded;
    private logTranspileResult;
    private filterOutFailedTests;
    private logInitialTestRunSucceeded;
    private logFailedTestsInInitialRun;
    private logErrorsInInitialRun;
    private logTimeoutInitialRun;
}
