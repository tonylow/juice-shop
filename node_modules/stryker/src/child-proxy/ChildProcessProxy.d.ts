import LoggingClientContext from '../logging/LoggingClientContext';
interface Func<TS extends any[], R> {
    (...args: TS): R;
}
interface PromisifiedFunc<TS extends any[], R> {
    (...args: TS): Promise<R>;
}
interface Constructor<T, TS extends any[]> {
    new (...args: TS): T;
}
export declare type Promisified<T> = {
    [K in keyof T]: T[K] extends PromisifiedFunc<any, any> ? T[K] : T[K] extends Func<infer TS, infer R> ? PromisifiedFunc<TS, R> : () => Promise<T[K]>;
};
export default class ChildProcessProxy<T> {
    readonly proxy: Promisified<T>;
    private worker;
    private initTask;
    private disposeTask;
    private currentError;
    private workerTasks;
    private log;
    private stdoutAndStderrBuilder;
    private isDisposed;
    private constructor();
    /**
    * Creates a proxy where each function of the object created using the constructorFunction arg is ran inside of a child process
    */
    static create<T, TS extends any[]>(requirePath: string, loggingContext: LoggingClientContext, plugins: string[], workingDirectory: string, _: Constructor<T, TS>, ...constructorArgs: TS): ChildProcessProxy<T>;
    private send;
    private initProxy;
    private forward;
    private listenForMessages;
    private listenToStdoutAndStderr;
    private reportError;
    private handleUnexpectedExit;
    private handleError;
    private innerProcessIsCrashed;
    dispose(): Promise<void>;
    private logUnidentifiedMessage;
}
export {};
