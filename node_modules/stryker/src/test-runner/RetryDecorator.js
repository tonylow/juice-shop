"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var test_runner_1 = require("stryker-api/test_runner");
var TestRunnerDecorator_1 = require("./TestRunnerDecorator");
var objectUtils_1 = require("../utils/objectUtils");
var OutOfMemoryError_1 = require("../child-proxy/OutOfMemoryError");
var logging_1 = require("stryker-api/logging");
var ERROR_MESSAGE = 'Test runner crashed. Tried twice to restart it without any luck. Last time the error message was: ';
/**
 * Wraps a test runner and implements the retry functionality.
 */
var RetryDecorator = /** @class */ (function (_super) {
    tslib_1.__extends(RetryDecorator, _super);
    function RetryDecorator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.log = logging_1.getLogger(RetryDecorator.name);
        return _this;
    }
    RetryDecorator.prototype.run = function (options, attemptsLeft, lastError) {
        if (attemptsLeft === void 0) { attemptsLeft = 2; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var error_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(attemptsLeft > 0)) return [3 /*break*/, 6];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 5]);
                        return [4 /*yield*/, this.innerRunner.run(options)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        error_1 = _a.sent();
                        if (error_1 instanceof OutOfMemoryError_1.default) {
                            this.log.info('Test runner process [%s] ran out of memory. You probably have a memory leak in your tests. Don\'t worry, Stryker will restart the process, but you might want to investigate this later, because this decreases performance.', error_1.pid);
                        }
                        return [4 /*yield*/, this.recover()];
                    case 4:
                        _a.sent();
                        return [2 /*return*/, this.run(options, attemptsLeft - 1, error_1)];
                    case 5: return [3 /*break*/, 8];
                    case 6: return [4 /*yield*/, this.recover()];
                    case 7:
                        _a.sent();
                        return [2 /*return*/, { status: test_runner_1.RunStatus.Error, errorMessages: [ERROR_MESSAGE + objectUtils_1.errorToString(lastError)], tests: [] }];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    RetryDecorator.prototype.recover = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.dispose()];
                    case 1:
                        _a.sent();
                        this.createInnerRunner();
                        return [2 /*return*/, this.init()];
                }
            });
        });
    };
    return RetryDecorator;
}(TestRunnerDecorator_1.default));
exports.default = RetryDecorator;
//# sourceMappingURL=RetryDecorator.js.map