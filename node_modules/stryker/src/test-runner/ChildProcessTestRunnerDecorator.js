"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ChildProcessProxy_1 = require("../child-proxy/ChildProcessProxy");
var ChildProcessTestRunnerWorker_1 = require("./ChildProcessTestRunnerWorker");
var objectUtils_1 = require("../utils/objectUtils");
var ChildProcessCrashedError_1 = require("../child-proxy/ChildProcessCrashedError");
var MAX_WAIT_FOR_DISPOSE = 2000;
/**
 * Runs the given test runner in a child process and forwards reports about test results
 * Also implements timeout-mechanism (on timeout, restart the child runner and report timeout)
 */
var ChildProcessTestRunnerDecorator = /** @class */ (function () {
    function ChildProcessTestRunnerDecorator(realTestRunnerName, options, sandboxWorkingDirectory, loggingContext) {
        this.worker = ChildProcessProxy_1.default.create(require.resolve('./ChildProcessTestRunnerWorker.js'), loggingContext, options.strykerOptions.plugins || [], sandboxWorkingDirectory, ChildProcessTestRunnerWorker_1.default, realTestRunnerName, options);
    }
    ChildProcessTestRunnerDecorator.prototype.init = function () {
        return this.worker.proxy.init();
    };
    ChildProcessTestRunnerDecorator.prototype.run = function (options) {
        return this.worker.proxy.run(options);
    };
    ChildProcessTestRunnerDecorator.prototype.dispose = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, objectUtils_1.timeout(
                        // First let the inner test runner dispose
                        this.worker.proxy.dispose().catch(function (error) {
                            // It's OK if the child process is already down. 
                            if (!(error instanceof ChildProcessCrashedError_1.default)) {
                                throw error;
                            }
                        }), 
                        // ... but don't wait forever on that
                        MAX_WAIT_FOR_DISPOSE)];
                    case 1:
                        _a.sent();
                        // After that, dispose the child process itself
                        return [4 /*yield*/, this.worker.dispose()];
                    case 2:
                        // After that, dispose the child process itself
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return ChildProcessTestRunnerDecorator;
}());
exports.default = ChildProcessTestRunnerDecorator;
//# sourceMappingURL=ChildProcessTestRunnerDecorator.js.map